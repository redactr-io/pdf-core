syntax = "proto3";

package redactr.pdf.v1;

service PdfService {
  // Returns page count, file size, metadata, and per-page analysis.
  rpc GetDocumentInfo(PdfInput) returns (DocumentInfoResponse);

  // Streams extracted text page-by-page, with optional word positions and OCR.
  rpc ExtractText(ExtractTextRequest) returns (stream PageTextResponse);

  // Searches for text strings and returns XFDF XML with highlight annotations for review.
  rpc GetSuggestionAnnotations(GetSuggestionAnnotationsRequest) returns (GetSuggestionAnnotationsResponse);

  // Applies XFDF highlight annotations as redactions, permanently removing matched content.
  rpc ApplyRedactions(ApplyRedactionsRequest) returns (ApplyRedactionsResponse);
}

// Raw PDF bytes input.
message PdfInput {
  bytes pdf_data = 1;
}

// --- GetDocumentInfo ---

message DocumentInfoResponse {
  int32 page_count = 1;
  int64 file_size_bytes = 2;
  bool is_encrypted = 3;
  bool has_text_content = 4;
  bool has_annotations = 5;
  int32 existing_annotation_count = 6;
  DocumentMetadata metadata = 7;
  repeated PageInfo pages = 8;
}

message DocumentMetadata {
  string title = 1;
  string author = 2;
  string producer = 3;
  string creator = 4;
}

message PageInfo {
  int32 page_number = 1;
  bool has_text = 2;
  bool has_images = 3;
  bool likely_scanned = 4;
  float width = 5;
  float height = 6;
}

// --- ExtractText ---

message ExtractTextRequest {
  bytes pdf_data = 1;
  // Zero-indexed page numbers to extract. Empty means all pages.
  repeated int32 pages = 2;
  // When true, includes per-line bounding box coordinates.
  bool include_word_positions = 3;
  // Optional OCR settings for scanned pages.
  OcrOptions ocr = 4;
}

message OcrOptions {
  bool enabled = 1;
  // Tesseract language code (default: "eng").
  string language = 2;
  // When true, forces OCR even on pages with existing text.
  bool force = 3;
}

message PageTextResponse {
  int32 page_number = 1;
  string text = 2;
  repeated TextBlock blocks = 3;
}

message TextBlock {
  string text = 1;
  float x0 = 2;
  float y0 = 3;
  float x1 = 4;
  float y1 = 5;
  int32 block_number = 6;
  int32 line_number = 7;
}

// --- GetSuggestionAnnotations ---

message GetSuggestionAnnotationsRequest {
  bytes pdf_data = 1;
  // Text strings to search for across all pages.
  repeated string texts = 2;
}

message GetSuggestionAnnotationsResponse {
  // XFDF XML containing highlight annotations for each match.
  string xfdf = 1;
  int32 total_suggestions = 2;
  // Per-text, per-page match counts (only pages with matches are included).
  repeated SuggestionResult results = 3;
}

message SuggestionResult {
  string text = 1;
  // Zero-indexed page number.
  int32 page = 2;
  int32 occurrences_found = 3;
}

// --- ApplyRedactions ---

message ApplyRedactionsRequest {
  bytes pdf_data = 1;
  // XFDF XML with highlight annotations to convert to redactions.
  string xfdf = 2;
}

message ApplyRedactionsResponse {
  bytes pdf_data = 1;
  int32 redactions_applied = 2;
  // SHA-256 hash of the output PDF bytes.
  bytes content_hash = 3;
}
